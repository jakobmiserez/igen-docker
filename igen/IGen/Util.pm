# ===================================================================
# IGen::Util
#
# (c) 2005, Networking team
#           Computing Science and Engineering Dept.
#           Universit√© catholique de Louvain
#           Belgium
#
# author Bruno Quoitin (bqu@info.ucl.ac.be)
# date 23/08/2005
# lastdate 12/12/2005
# ===================================================================

package IGen::Util;

require Exporter;
@ISA= qw(Exporter);
@EXPORT= qw(text2capacity
	    capacity2text
	    replace_file_ext
	    save_stat_data
	    save_stat_fdistrib
	    string2filename
	    );

use strict;

# -----[ text2capacity ]---------------------------------------------
# Convert a string describing a bandwidth into an integer value.
#
# Capacities have the form <Number> (k|m|g)
# -------------------------------------------------------------------
sub text2capacity($)
{
    my ($text_capacity)= @_;

    $text_capacity= lc($text_capacity);

    if ($text_capacity =~ m/^([0-9.]+)(e[0-9]+)?\s*(k|m|g)?$/) {
	my $capacity= $1;

	if (defined($2) && ($2 =~ m/^e([0-9]+)$/)) {
	    $capacity*= "1e$1";
	}

	if (defined($3)) {
	    if ($3 eq "k") {
		$capacity*= 1e3;
	    } elsif ($3 eq "m") {
		$capacity*= 1e6;
	    } elsif ($3 eq "g") {
		$capacity*= 1e9;
	    } else {
		printf STDERR "Error: invalid capacity \"%s\"\n",
		$text_capacity;
		return undef;
	    }
	}
	return $capacity;
    } else {	
	printf STDERR "Error: invalid capacity \"%s\"\n",
	$text_capacity;
	return undef;
    }
}

# -----[ capacity2text ]---------------------------------------------
# Convert an integer value to a string value
# -------------------------------------------------------------------
sub capacity2text($)
{
    my ($capacity)= @_;
    my @units= ('', 'K', 'M', 'G');
    my $divisions= 0;

    while ((($capacity % 1000) == 0) && ($divisions < 3)) {
	$divisions++;
	$capacity/= 1000;
    }
    if (($divisions < 3) && (($capacity % 100) == 0)) {
	$divisions++;
	$capacity/= 1000;
    }

    return "$capacity$units[$divisions]";
}

# -----[ save_stat_data ]--------------------------------------------
# Save the provided array of data in a file. The array may be
# 2-dimensional, i.e. each cell is a reference to an array.
#
# Return value:
#   0  in case of success
#  -1  in case of failure
# -------------------------------------------------------------------
sub save_stat_data($$;%)
{
    my ($data, $file, %args)= @_;

    (!open(DATA, ">$file")) and
	return -1;
    print DATA "# Stat DATA file\n";
    print DATA "# Generated by IGen on ".localtime(time)."\n";
    print DATA "#\n";
    foreach (@$data) {
	if (ref($_) eq 'ARRAY') {
	    print DATA "".(join "\t", @$_)."\n";
	} else {
	    print DATA "$_\n";
	}
    }
    close(DATA);
    return 0;
}

# -----[ save_stat_fdistrib ]----------------------------------------
# Save the provided distribution in a file.
#
# Authorized options:
#  -cumulative : show a cumulative distribution
#  -relative   : the y-index will be relative (i.e. divided by max)
#  -inverse    : inverse cumulative distribution (-cumulative must be
#                specified)
#  -binmean    : the x-index will be the mean of the (x)th and (x+1)th
#                indexes (this can be used for non-integer bins)
#
# Return value:
#   0  in case of success
#  -1 in case of failure
# -------------------------------------------------------------------
sub save_stat_fdistrib($$;%)
{
    my ($stat, $filename, %args)= @_;

    # ---| Get precomputed frequency distribution |---
    my %fdist= $stat->frequency_distribution();
    open(TMP, ">$filename") or
	return -1;
    print TMP "# Stat FREQUENCY DISTRIBUTION file\n";
    print TMP "# Generated by IGen on ".localtime(time)."\n";
    print TMP "#\n";
    foreach (keys %args) {
	print TMP "# arg [$_] => \"$args{$_}\"\n";
    }
    print TMP "#\n";
    my $prev= $stat->min();
    my $value= 0;
    if ($args{-cumulative} && $args{-inverse}) {
	if ($args{-relative}) {
	    $value= 1;
	} else {
	    $value= $stat->count();
	}
    }
    foreach my $index (sort {$a <=> $b} keys %fdist) {
	my $data= $fdist{$index};
	($args{-relative}) and
	    $data/= $stat->count();
	if ($args{-cumulative}) {
	    if ($args{-inverse}) {
		$value-= $data;
	    } else {
		$value+= $data;
	    }
	} else {
	    $value= $data;
	}
	if (exists($args{-binmean}) && $args{-binmean}) {
	    $index= $prev+($index-$prev)/2;
	}
	printf TMP "%f\t%f\n", $index, $value;
	$prev= $index;
    }
    close(TMP);
    return 0;
}

# -----[ string2filename ]-------------------------------------------
# This function converts a string to another string suitable to be
# used in a filename. For this purpose, the function translates any
# character that does not belong to one of the following sets:
#  [a-z], [A-Z], [0-9], [-_]
#
# Arguments:
#  - input string
#
# Return value:
#  - output string (filtered)
# -------------------------------------------------------------------
sub string2filename($)
{
    my ($string)= @_;
    
    $string =~ tr/ :./-__/;
    $string =~ s/[^a-zA-Z0-9\-_]/_/g;
    return $string;
}

# -----[ replace_file_ext ]------------------------------------------
# This function replaces the extension of the given file by another
# one. If the original file has no extension, the new extension is
# appended.
#
# Arguments:
#  - filename
#  - new file extension (without the '.')
#
# Return value:
#  - updated filename
# -------------------------------------------------------------------
sub replace_file_ext($$)
{
    my ($filename, $ext)= @_;

    (!($filename =~ s/^(.+)(\.[a-zA-Z0-9_]+)$/$1.$ext/)) and
	$filename.= ".$ext";
    return $filename;
}
