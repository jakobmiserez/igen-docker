# ===================================================================
# IGen::FilterBRITE
#
# (c) 2005, Networking team
#           Computing Science and Engineering Dept.
#           UniversitÃ© catholique de Louvain
#           Belgium
#
# author Bruno Quoitin (bqu@info.ucl.ac.be)
# date 22/08/2005
# lastdate 14/09/2005
# ===================================================================

package IGen::FilterBRITE;

require Exporter;
@ISA= qw(Exporter IGen::FilterBase);

use strict;
use IGen::FilterBase;

# -----[ _init ]-----------------------------------------------------
#
# -------------------------------------------------------------------
sub _init()
{
    my ($self)= @_;

    $self->SUPER::_init();
    $self->set_capabilities(IGen::FilterBase::IMPORT_SINGLE |
			    IGen::FilterBase::EXPORT_SINGLE);
}

# -----[ import_graph ]----------------------------------------------
#
# -------------------------------------------------------------------
sub import_graph($$)
{
    my ($self, $filename)= @_;
    my $graph= new Graph::Undirected;
    $graph->set_attribute(UCL::Graph::ATTR_GFX, 1);
    my $num_nodes= undef;
    my $num_edges= undef;

    if (!open(BRITE, "<$filename")) {
	$self->set_error("unable to open BRITE file \"$filename\": $!");
	return undef;
    }

    # Read header: Topology & Model
    $_= <BRITE>;
    chomp;
    if ($_ =~ m/^\s*Topology\s*\:\s*\(\s*([0-9]+)\s+Nodes\,\s*([0-9]+)\s+Edges\s*\)\s*$/) {
	$num_nodes= $1;
	$num_edges= $2;
    } else {
	$self->set_error("missing 'Topology' header");
	close(BRITE);
	return undef;
    }
    $_= <BRITE>;
    chomp;
    if ($_ =~ m/^Model\s+\(\s*([1-9]+)\s*\-\s*(.+)\s*\)\s*\:.+$/) {
	my $model= $1;
	my $model_descr= $2;
	#if ($model != 1) {
	#    $self->set_error("unsupported model ($model - $model_descr)");
	#    close(BRITE);
	#    return undef;
	#}
    } else {
	$self->set_error("missing 'Model' header");
	close(BRITE);
	return undef;
    }
    while (($_= <BRITE>) =~ m/^\s*$/) {};

    # ---| Read nodes |---
    chomp;
    if ($_ =~ m/^Nodes\s*\:\s*\(\s*([0-9]+)\s*\)\s*$/) {
	if ($num_nodes != $1) {
	    $self->set_error("incoherent file (num. nodes differ)");
	    close(BRITE);
	    return undef;
	}
    } else {
	$self->set_error("missing 'Nodes' header");
	close(BRITE);
	return undef;
    }
    for (my $i= 0; $i < $num_nodes; $i++) {
	$_= <BRITE>;
	chomp;
	my @fields= split /\s+/, $_;
	if (scalar(@fields) != 7) {
	    $self->set_error("syntax error (invalid number of fields in Node record");
	    close(BRITE);
	    return undef;
	}
	if ($fields[6] ne 'RT_NODE') {
	    $self->set_error("unsupported node type $fields[6]");
	    close(BRITE);
	    return undef;
	}
	$graph->add_vertex($fields[0]);
	if (($fields[1] > -180) || ($fields[1] < 180) || ($fields[2] > -90) || ($fields[2] < 90)) {
	} else {
	    $self->set_error("invalid coordinates ($fields[1], $fields[2])");
	    close(BRITE);
	    return undef;
	}
	$graph->set_attribute(UCL::Graph::ATTR_COORD, $fields[0],
			      [$fields[1], $fields[2]]);
    }
    while (($_= <BRITE>) =~ m/^\s*$/) {};

    # ---| Read edges |---
    chomp;
    if ($_ =~ m/^Edges\s*\:\s*\(\s*([0-9]+)\s*\)\s*$/) {
	if ($num_edges != $1) {
	    $self->set_error("incoherent file (num. edges differ)");
	    close(BRITE);
	    return undef;
	}
    } else {
	$self->set_error("missing 'Edges' header [$_]");
	close(BRITE);
	return undef;
    }    
    for (my $i= 0; $i < $num_edges; $i++) {
	$_= <BRITE>;
	chomp;
	my @fields= split /\s+/, $_;
	if (scalar(@fields) < 9) {
	    $self->set_error("syntax error (invalid number of fields in Edge record");
	    close(BRITE);
	    return undef;
	}
	if ($fields[8] ne 'E_RT') {
	    $self->set_error("unsupported edge type $fields[8]");
	    close(BRITE);
	    return undef;
	}
	$graph->add_edge($fields[1], $fields[2]);
    }

    close(BRITE);
    return $graph;
}

# -----[ export_graph ]----------------------------------------------
#
# -------------------------------------------------------------------
sub export_graph($$$)
{
    my ($self, $graph, $filename)= @_;

    my $as= -1;
    if ($graph->has_attribute(UCL::Graph::ATTR_AS)) {
	$as= $graph->get_attribute(UCL::Graph::ATTR_AS);
    }

    my @vertices= $graph->vertices();
    my @edges= $graph->edges();

    (open(BRITE, ">$filename")) or
	die "Error: unable to create BRITE file \"$filename\": $!";

    # ---| Header |---
    print BRITE "Topology: ( ".scalar(@vertices)." Nodes, ".
	(scalar(@edges)/2)." Edges )\n";
    print BRITE "Model ( 1 - XXX ): generated by IGen::FilterBRITE ".
	"on ".localtime(time)."\n";
    print BRITE "\n";

    # ---| Generate vertices |---
    # Each vertex is represented by a line composef of
    #   <NodeId> <xpos> <ypos> <indegree> <outdegree> <ASid> <type>
    print BRITE "Nodes: (".scalar(@vertices).")\n";
    foreach my $v (sort {$a <=> $b} @vertices) {
	my $coord= $graph->get_attribute(UCL::Graph::ATTR_COORD, $v);
	my $indegree= scalar($graph->predecessors($v));
	my $outdegree= scalar($graph->predecessors($v));
	print BRITE "$v $coord->[0] $coord->[1] ".
	    "$indegree $outdegree $as RT_NONE\n";
    }
    print BRITE "\n";

    # ---| Generate edges |---
    # Each edge is represented by a line composed of
    #   <EdgeId> <from> <to> <length> <delay>
    #   <bandwidth> <ASfrom> <ASto> <type> <direction>
    # Note that the last <direction> field is not documented in
    # BRITE's user manual but it is required by BRITE.
    print BRITE "Edges: (".(scalar(@edges)/2).")\n";
    for (my $i= 0; $i < scalar(@edges)/2; $i++) {
	my $u= $edges[$i*2];
	my $v= $edges[$i*2+1];
	my $length= 0;
	my $delay= 0;
	my $bandwidth= 0;
	if ($graph->has_attribute(UCL::Graph::ATTR_CAPACITY, $u, $v)) {
	    $bandwidth=
		$graph->get_attribute(UCL::Graph::ATTR_CAPACITY,
				      $u, $v);
	}
	print BRITE "$i $u $v $length $delay $bandwidth ".
	    "$as $as E_RT_NONE U\n";
    }

    close(BRITE);
    return 0;
}
