# ===================================================================
# IGen::FilterGMT
#
# (c) 2005, Networking team
#           Computing Science and Engineering Dept.
#           UniversitÃ© catholique de Louvain
#           Belgium
#
# author Bruno Quoitin (bqu@info.ucl.ac.be)
# date 07/09/2005
# lastdate 07/09/2005
# ===================================================================

package IGen::FilterGMT;

require Exporter;
@ISA= qw(Exporter IGen::FilterBase);

use strict;
use IGen::FilterBase;
use IGen::Util;
use UCL::Progress;

# -----[ _init ]-----------------------------------------------------
#
# -------------------------------------------------------------------
sub _init()
{
    my ($self)= @_;

    $self->SUPER::_init();
    $self->set_capabilities(IGen::FilterBase::EXPORT_SINGLE |
			    IGen::FilterBase::EXPORT_MULTIPLE);
    $self->set_extensions('.ps');
}

# -----[ import_graph ]----------------------------------------------
#
# -------------------------------------------------------------------
sub import_graph($$)
{
    my ($self, $filename)= @_;

    $self->set_error("Import not implemented");
    return undef;
}

# -----[ export_graph ]----------------------------------------------
#
# -------------------------------------------------------------------
sub export_graph($$$)
{
    my ($self, $graphs, $filename)= @_;

    my $tmp_filename= "/tmp/.igen-gmt";

    if (!open(GMT, ">$tmp_filename")) {
	$self->set_error("unable to create temporary file \"$tmp_filename\": $!");
	return -1;
    }

    # ---| Single domain: convert to hash of domains |---
    if (ref($graphs) ne "HASH") {
	$graphs= {
	    'as2graph' => {
		$graphs->get_attribute(UCL::Graph::ATTR_AS) => $graphs
		},
		};
    }

    my $progress= new UCL::Progress;
    $progress->{message}= "Exporting ";
    $progress->{verbose}= 1;
    $progress->{pace}= 1;
    $progress->{percent}= 0;
    my $cnt= 0;

    # ---| Generate temporary file with routers' coordinates |---
    print GMT "# Generated by IGen::FilterGMT\n";
    print GMT "# on ".localtime(time())."\n";
    print GMT "# <latitude (Y)> <longitude (X)>\n";
    my ($min_x, $min_y, $max_x, $max_y)= (undef, undef, undef, undef);
    foreach my $graph (values %{$graphs->{as2graph}}) {
	my $as_id= $graph->get_attribute(UCL::Graph::ATTR_AS);
	foreach my $vertex ($graph->vertices()) {
	    if (!$graph->has_attribute(UCL::Graph::ATTR_COORD, $vertex)) {
		$self->set_error("node $vertex in domain $as_id has no coordinates");
		close(GMT);
		return -1;
	    }
	    my $coord= $graph->get_attribute(UCL::Graph::ATTR_COORD,
					     $vertex);
	    # ---| Compute the graph's geographical extent |---
	    if (!defined($min_x) || ($min_x > $coord->[0])) {
		$min_x= $coord->[0];
	    }
	    if (!defined($min_y) || ($min_y > $coord->[1])) {
		$min_y= $coord->[1];
	    }
	    if (!defined($max_x) || ($max_x < $coord->[0])) {
		$max_x= $coord->[0];
	    }
	    if (!defined($max_y) || ($max_y < $coord->[1])) {
		$max_y= $coord->[1];
	    }
	    # ---| Write coordinates |---
	    # Node: symbol for 'psxy' could be added in 3rd column
	    # (see -S parameter)
	    print GMT "$coord->[1]\t$coord->[0]\n";
	    
	    $cnt++;
	    $progress->progress($cnt);
	}
    }
    close(GMT);
    $progress->end($cnt);

    my $delta_x= ($max_x-$min_x);
    my $delta_y= ($max_y-$min_y);

    print "Delta X: $delta_x\n";
    print "Delta Y: $delta_y\n";

    # ---| Compute size of margins |---
    my $margin_factor= 0.25;
    $min_x-= $delta_x*$margin_factor;
    $max_x+= $delta_x*$margin_factor;
    $min_y-= $delta_y*$margin_factor;
    $max_y+= $delta_y*$margin_factor;

    ($min_x < -180) and $min_x= -180;
    ($max_x > 180) and $max_x= 180;
    ($min_y < -80) and $min_y= -80;
    ($max_y > 80) and $max_y= 80;

    # ---| Select symbol |---
    # a : star
    # e : ellipse
    # h : hexagon
    # i : inverted triangle
    # o : octagon
    # n : pentagon
    # p : point (1 pixel)
    # s : square
    # t : triangle
    # x : cross
    my $symbol= 'i';
    my $symbol_size_factor= 360/$delta_x;
    if ($symbol_size_factor > 180/$delta_y) {
	$symbol_size_factor= 180/$delta_y;
    }
    my $symbol_size= (0.001*$symbol_size_factor).'i';

    # ---| Call GMT's pscoast in order to get the coastlines |---
    system "pscoast -R$min_x/$max_x/$min_y/$max_y -JM6i -G200 -N1 -K > $filename";
    # ---| Call GMT's psxy to add the routers' positions |---
    # -G specifies fill options
    # -W specifies pen options
    system "psxy $tmp_filename -: -R -JM -S$symbol$symbol_size -G255/0/0 -W0.01i/255/0/0 -O >> $filename";

    # ---| Remove temporary file |---
    unlink("$tmp_filename");

    $self->set_error();
    return 0;
}
